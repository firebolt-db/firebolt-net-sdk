#region License Apache 2.0

/* Copyright 2022 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#endregion

using static System.Net.HttpStatusCode;
using FireboltDotNetSdk.Exception;
using static FireboltDotNetSdk.Utils.Constant;
using Newtonsoft.Json;
using FireboltDotNetSdk.Client;
using static FireboltDotNetSdk.Client.FireRequest;
using static FireboltDotNetSdk.Client.FireResponse;

namespace FireboltDotNetSdk;
public class FireboltClient1 : FireboltClient
{
    private readonly Lazy<JsonSerializerSettings> _settings;
    private readonly string _account;

    private readonly static ISet<string> ENGINE_NOT_READY_STATUSES = new HashSet<string>()
    {
            "ENGINE_STATUS_PROVISIONING_STARTED", "ENGINE_STATUS_PROVISIONING_PENDING",
            "ENGINE_STATUS_PROVISIONING_FINISHED", "ENGINE_STATUS_RUNNING_REVISION_STARTING"
    };
    public FireboltClient1(FireboltConnection connection, string id, string secret, string endpoint, string? env, string account, HttpMessageInvoker httpClient) : base(connection, id, secret, endpoint, env, null, httpClient)
    {
        _settings = new Lazy<JsonSerializerSettings>(new JsonSerializerSettings());
        _account = account;
    }

    public override async Task<ConnectionResponse> ConnectAsync(string? engineName, string databaseName, CancellationToken cancellationToken)
    {
        try
        {
            await EstablishConnection();
        }
        catch (FireboltException e) when (e.StatusCode == Forbidden)
        {
            // Patch that "fixes" bad return code generated by the server and makes it complatible with FireboltClient2
            throw new FireboltException(Unauthorized, "The operation is unauthorized\nStatus: " + Unauthorized);
        }
        string? accountId;
        try
        {
            accountId = _account != string.Empty ? (await GetAccountIdByNameAsync(_account, cancellationToken)).id : null;
        }
        catch (FireboltException e) when (e.StatusCode == NotFound)
        {
            throw new FireboltException(NotFound, $"Account with name {_account} was not found");
        }

        try
        {
            string? engineUrl = null;
            if (engineName != null)
            {
                engineUrl = await GetEngineUrlByEngineName(accountId, engineName!, cancellationToken);
            }
            else if (databaseName != null)
            {
                engineUrl = await GetDefaultEngineUrl(accountId, databaseName, cancellationToken);
            }
            if (engineUrl == null)
            {
                throw new FireboltException(engineName != null ? $"Engine {engineName} not found." : $"Cannot get url of default engine url from {databaseName} database");
            }
            return new ConnectionResponse(engineUrl!, databaseName!, FireboltConnection.SYSTEM_ENGINE.Equals(engineName));
        }
        catch (System.Exception ex)
        {
            throw new FireboltException(engineName != null ? $"Engine {engineName} not found." : $"Cannot get url of default engine url from {databaseName} database", ex);
        }
    }

    protected override Task<LoginResponse> Login(string username, string password, string env)
    {
        var credentials = new UsernamePasswordLoginRequest(username, password);
        return SendAsync<LoginResponse>(HttpMethod.Post, $"https://{_endpoint}{AUTH_USERNAME_PASSWORD_URL}", JsonConvert.SerializeObject(credentials, _settings.Value), _jsonContentType, false, CancellationToken.None, false);
    }

    private async Task<string?> GetDefaultEngineUrl(string? accountId, string database, CancellationToken cancellationToken)
    {
        return await GetEngineAttribute<GetEngineUrlByDatabaseNameResponse>(accountId, "engines:getURLByDatabaseName?databaseName=" + database, engineByDatabase => engineByDatabase.Engine_url, cancellationToken);
    }

    private async Task<string?> GetEngineUrlByEngineName(string? accountId, string engineName, CancellationToken cancellationToken)
    {
        string? engineId = await GetEngineAttribute<GetEngineIdByEngineNameResponse>(accountId, "engines:getIdByName?engine_name=" + engineName, engineByName => engineByName.engine_id?.engine_id, cancellationToken);
        if (engineId == null)
        {
            throw new FireboltException($"Cannot find an engine with name: {engineName}");
        }

        string? engineUrl = await GetEngineAttribute<GetEngineUrlByEngineNameResponse>(accountId, "engines/" + engineId, engineById => engineById.engine?.endpoint, cancellationToken);
        if (ENGINE_NOT_READY_STATUSES.Contains(engineUrl ?? ""))
        {
            throw new FireboltException($"The engine {engineName} is currently starting. Please wait until the engine is on and then execute the query again.");
        }
        return engineUrl;
    }

    private async Task<string?> GetEngineAttribute<T>(string? accountId, string suffix, Func<T, string?> attributeGetter, CancellationToken cancellationToken)
    {
        string engineByNameUrl = CreateAccountUri(accountId, suffix);
        T engineByName = await SendAsync<T>(HttpMethod.Get, engineByNameUrl, null, true, cancellationToken, false);
        return attributeGetter.Invoke(engineByName);
    }

    private string CreateAccountUri(string? accountId, string suffix)
    {
        string accountPath = accountId == null ? "/" : $"s/{accountId}/";
        return $"https://{_endpoint}/core/v1/account{accountPath}{suffix}";
    }

    public override async Task<GetAccountIdByNameResponse> GetAccountIdByNameAsync(string accountName, CancellationToken cancellationToken)
    {
        if (accountName == string.Empty)
        {
            return await Task.FromResult(new GetAccountIdByNameResponse() { id = null });
        }
        string url = $"https://{_endpoint}/iam/v2/accounts:getIdByName?accountName={accountName}";
        return await GetJsonResponseAsync<GetAccountIdByNameResponse>(HttpMethod.Get, url, null, requiresAuth: true, cancellationToken);
    }
}
